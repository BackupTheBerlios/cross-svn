/*
 * Created on Aug 5, 2004
 *
 */
package fr.cnrs.liris.cross;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Iterator;
import java.util.LinkedList;

import com.hp.hpl.jena.graph.Graph;
import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.graph.TripleMatch;
import com.hp.hpl.jena.graph.impl.GraphBase;
import com.hp.hpl.jena.shared.ReificationStyle;
import com.hp.hpl.jena.util.iterator.ExtendedIterator;
import com.hp.hpl.jena.vocabulary.OWL;
import com.hp.hpl.jena.vocabulary.RDF;
import com.hp.hpl.jena.vocabulary.RDFS;

/**
 * @author Pierre-Antoine Champin
 *
 * <p>The graph corresponding to the ABox for a database.</p>
 * <p>This class implements <code>com.hp.hpl.jena.graph.Graph</code>, around which
 * RDF models can be created.</p> 
 * 
 * @see fr.cnrs.liris.cross.DbInfo
 * @see fr.cnrs.liris.cross.TBoxGraph
 */
public class ABoxGraph extends GraphBase implements Graph {
	
    /**
     * The DbInfo this graph is a representation of.
     */
	private DbInfo info;

    /**
     * Construct the ABoxGraph for the given DbInfo. 
     * @param info the description of the database
     * @param style the ReificationStyle of the graph
     */
	public ABoxGraph ( DbInfo info, ReificationStyle style ) {
		super (style);
		this.info = info;
	}
        
    /**
     * Construct the ABoxGraph for the given DbInfo. 
     * @param info the description of the database
     */
	public ABoxGraph (DbInfo info) {
		super ();
		this.info = info;
	}
        

	/* (non-Javadoc)
	 * @see com.hp.hpl.jena.graph.Graph#find(com.hp.hpl.jena.graph.TripleMatch)
	 */
	public ExtendedIterator find(TripleMatch m) {
		// TODO LATER This could be optimized...
		return new com.hp.hpl.jena.graph.TripleMatchIterator (
			m.asTriple(), new ABoxIterator ());
	}
	
	private class ABoxIterator implements java.util.Iterator {
		private Iterator tables;
		private Table table;
		private ResultSet rs;
		private Iterator triples;
		private boolean hasNext = true;

		ABoxIterator () {
			tables = info.tables.values ().iterator ();
			try {
				fillResultSet ();
                LinkedList header = new LinkedList();
                Node ont = Node.createURI(info.getABoxUri());
                //Node ont = Node.createURI("");
                header.add (new Triple(ont,
                                       RDF.type.asNode(),
                                       OWL.Ontology.asNode()));
                header.add (new Triple(ont,
                                       RDFS.comment.asNode(),
                                       Node.createLiteral(
                                           "Generated by Cross", null, null)));
                header.add (new Triple(ont,
                                       OWL.imports.asNode(),
                                       Node.createURI(
                                           info.getImportedTboxUri())));
                triples = header.iterator();
				findNext ();
			}
			catch (SQLException ex) {
				throw new RuntimeException (ex);
			}
		}
		
		private void findNext () throws SQLException {
			while (!triples.hasNext ()) {
				while (!rs.next ()) {
					if (!tables.hasNext ()) {
						hasNext = false;
						return;
					}
					fillResultSet ();
				}
				fillTriples ();
			}
		}
		
		private void fillResultSet () throws SQLException {
			table = (Table) tables.next();
			String table_name = table.sqlname;
			StringBuffer select = new StringBuffer ("SELECT ");
			StringBuffer from = new StringBuffer (" FROM " + table_name);
			boolean first = true;
			Iterator i = table.columnList.iterator();
			
			while (i.hasNext ()) {
				Column column = (Column) i.next ();
				if (first) first = false;
				else select.append (",");
				select.append(table_name)
				      .append(".")
				      .append (column.sqlname)
					  .append(" AS ")
					  .append (column.sqlname);
			}
			i = table.foreignKeys.values().iterator();
			
			while (i.hasNext ()) {
				ForeignKey fk = (ForeignKey) i.next ();
				Table ft = fk.foreignColumnSet().table();
				
				Iterator j = ft.primaryKey.columnList.iterator();
				while (j.hasNext()) {
					Column c = (Column) j.next();
					select.append(",")
						  .append(fk.sqlname)
						  .append(".")
						  .append(c.sqlname)
						  .append(" AS ")
						  .append(info.quote)
                              .append(fk.name).append("_").append(c.name)
                          .append(info.quote);
				}
				
				from.append(" LEFT JOIN ")
					.append(ft.sqlname)
					.append(" ")
					.append(fk.sqlname)
				    .append(" ON(");
				first = true;
				j = fk.columnList.iterator();
				while (j.hasNext()) {
					if (first) first = false;
					else from.append(",");
					Column c0 = (Column) j.next();
					Column c1 = (Column) fk.mapping.get(c0);
					from.append(table_name)
					    .append(".")
					    .append(c0.sqlname)
					    .append("=")
					    .append(fk.sqlname)
					    .append(".")
					    .append(c1.sqlname);
				}
				from.append (") ");
			}
			select.append (from);
			java.sql.Connection cx = info.openConnection();
			java.sql.Statement s = cx.createStatement();
            // System.err.println(select); // DEBUG
			rs = s.executeQuery(select.toString ());
		}
		
		private void fillTriples () throws SQLException {
            LinkedList list = new LinkedList ();
            
			// rule 1
            Iterator col_it =
            new TransformIterator(table.primaryKey.columnList.iterator()) {
                public Object transform (Object o) {
                    return ((Column)o).name;
                }
            };
			Node s = Node.createURI(info.uri(rs, col_it, table));
            Node table_node = Node.createURI(table.uri);
            list.add (new Triple (s, RDF.type.asNode(), table_node));
            
            // rule 2
			Iterator i = table.columnList.iterator();
			while (i.hasNext()) {
				Column c = (Column) i.next();
				String value = rs.getString (c.name);
                if (value == null) continue;
				Node p = Node.createURI(c.uri);
				Node o = Node.createLiteral(value,
				                            null,
				                            Datatypes.xsdType(c.type));
                list.add (new Triple (s, p, o));
			}
            
            // rule 3
            i = table.foreignKeys.values().iterator();
            while (i.hasNext()) {
                ForeignKey fk = (ForeignKey) i.next();
                Node o = nodeForFK (fk);
                if (o == null) continue;
                
                if (!fk.subsumesPrimaryKey()) {
                    // rule 3a
                    Node p = Node.createURI(fk.uri);
                    list.add (new Triple (s, p, o));
                } else {
                    // rule 3b
                    list.add (new Triple (s, OWL.sameAs.asNode(), o));
                }
            }
            
            // rule 4
            i = table.fkPairs.iterator();
            while (i.hasNext ()) {
                final ForeignKey[] pair = (ForeignKey[]) i.next();
                Node p = Node.createURI (info.uri (pair[0], pair[1], table));
                Node s0 = nodeForFK (pair[0]);
                Node o = nodeForFK (pair[1]);
                if (s0 == null || o == null) continue;
                list.add (new Triple (s0, p, o));
            }
            
            triples = list.iterator();
		}
        
        private Node nodeForFK (final ForeignKey fk) {
            Table ft = fk.foreignColumnSet().table();
            Iterator fk_it =
            new TransformIterator(ft.primaryKey.columnList.iterator()) {
                public Object transform (Object o) {
                    return fk.name+"_"+((Column)o).name;
                }
            };
            String uri = info.uri (rs, fk_it, ft);
            if (uri == null) return null;
            else return Node.createURI(uri);
        }
		
		public boolean hasNext () {
			return hasNext;
		}
		
		public Object next () {
			Object r = triples.next ();
			try { findNext (); }
			catch (SQLException ex) { throw new RuntimeException(ex); }
			return r;
		}
		
		public void remove () {
			throw new UnsupportedOperationException ();
		}
	}
}
