/*
 * Created on Aug 5, 2004
 *
 */
package fr.cnrs.liris.cross;

import java.util.Iterator;
import java.util.LinkedList;

import com.hp.hpl.jena.graph.Graph;
import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.graph.TripleMatch;
import com.hp.hpl.jena.graph.impl.GraphBase;
import com.hp.hpl.jena.rdf.model.AnonId;
import com.hp.hpl.jena.shared.ReificationStyle;
import com.hp.hpl.jena.util.iterator.ExtendedIterator;
import com.hp.hpl.jena.vocabulary.OWL;
import com.hp.hpl.jena.vocabulary.RDF;
import com.hp.hpl.jena.vocabulary.RDFS;

/**
 * @author Pierre-Antoine Champin
 *
 * <p>The graph corresponding to the TBox for a database.</p>
 * <p>This class implements <code>com.hp.hpl.jena.graph.Graph</code>, around which
 * RDF models can be created.</p> 
 * 
 * @see fr.cnrs.liris.cross.ABoxGraph
 * @see fr.cnrs.liris.cross.DbInfo
 */
public class TBoxGraph extends GraphBase implements Graph {

    /**
     * The DbInfo this graph is a representation of.
     */
	DbInfo info;
    
    /**
     * The OWL language level this TBoxGraph corresponds to.
     * @see fr.cnrs.liris.cross.LanguageLevel 
     */
    public final int languageLevel;

    /**
     * Construct the TBoxGraph for the given DbInfo, with the given languageLevel.
     * @param info the description of the database
     * @param languageLevel the language level to set for this graph
     * @param style the ReificationStyle of the graph
     * 
     * @see #languageLevel
     */
	public TBoxGraph ( DbInfo info, int languageLevel, ReificationStyle style ) {
		super (style);
		this.info = info;
        this.languageLevel = languageLevel;
	}

    /**
     * Construct the TBoxGraph for the given DbInfo, with the given languageLevel.
     * @param info the description of the database
     * @param languageLevel the language level to set for this graph
     * 
     * @see #languageLevel
     */
    public TBoxGraph ( DbInfo info, int languageLevel) {
        super ();
        this.info = info;
        this.languageLevel = languageLevel;
    }
        
    /**
     * Construct the TBoxGraph for the given DbInfo, with the default language level.
     * @param info the description of the database
     * 
     * @see #languageLevel
     */
	public TBoxGraph (DbInfo info) {
		super ();
		this.info = info;
        this.languageLevel = LanguageLevel.DEFAULT;
	}
        

	/* (non-Javadoc)
	 * @see com.hp.hpl.jena.graph.Graph#find(com.hp.hpl.jena.graph.TripleMatch)
	 */
	public ExtendedIterator find(TripleMatch m) {
		// TODO LATER This could be optimized...
		return new com.hp.hpl.jena.graph.TripleMatchIterator (m.asTriple(), findAll ());
	}
    
	private Iterator findAll () {
		LinkedList list = new LinkedList ();
		
        Node ont = Node.createURI(info.getTBoxUri());
        //Node ont = Node.createURI("");
        list.add (new Triple(ont,
                             RDF.type.asNode(),
                             OWL.Ontology.asNode()));
        list.add (new Triple(ont,
                             RDFS.comment.asNode(),
                             Node.createLiteral(
                                 "Generated by Cross", null, null)));
                                   
		Iterator i = info.tables.values ().iterator();
		while (i.hasNext ()) {
			Table table = (Table) i.next ();
			Node table_node = Node.createURI (table.uri);
			// rule 1
			list.add (new Triple (table_node,
			                      RDF.type.asNode (),
			                      OWL.Class.asNode ()));
			
			Iterator j = table.columnList.iterator() ;
			while (j.hasNext ()) {
				Column column = (Column) j.next ();
				Node col_node = Node.createURI (column.uri);
				Node datatype = Node.createURI (Datatypes.xsdTypeUri (column.type));
				// rule 2
				list.add (new Triple (col_node,
									  RDF.type.asNode (),
									  OWL.DatatypeProperty.asNode ()));
				list.add (new Triple (col_node,
									  RDF.type.asNode (),
									  OWL.FunctionalProperty.asNode ()));
				list.add (new Triple (col_node,
									  RDFS.domain.asNode (),
									  table_node));
				list.add (new Triple (col_node,
									  RDFS.range.asNode (),
									  datatype));
				if (!column.canBeNull) {
                    AnonId aid = new AnonId (
                        "restriction:"+col_node.getURI());
                    Node restriction = Node.createAnon (aid);
                    list.add (new Triple (table_node,
                                          RDFS.subClassOf.asNode(),
                                          restriction));
                    list.add (new Triple (restriction,
                                          RDF.type.asNode(),
                                          OWL.Restriction.asNode ()));
                    list.add (new Triple (restriction,
                                          OWL.onProperty.asNode(),
                                          col_node));
                    list.add (new Triple (restriction,
                                          OWL.someValuesFrom.asNode(),
                                          datatype));
				}
				if (column.unique) {
                    if (languageLevel >= LanguageLevel.OWL_FULL) {
                        list.add (new Triple (col_node,
                                              RDF.type.asNode (),
                                              OWL.InverseFunctionalProperty
                                                  .asNode ()));
                    }
				}
			}
			
			j = table.foreignKeys.values ().iterator();
			while (j.hasNext ()) {
				ForeignKey fk = (ForeignKey) j.next ();
				Node fk_node = Node.createURI (fk.uri);
				Table ftable = fk.foreignColumnSet ().table ();
				Node ftable_node = Node.createURI (ftable.uri);
				
				if (!fk.subsumesPrimaryKey()) {
					// rule 3a
					list.add (new Triple (fk_node,
										  RDF.type.asNode (),
										  OWL.ObjectProperty.asNode ()));
					list.add (new Triple (fk_node,
										  RDF.type.asNode (),
										  OWL.FunctionalProperty.asNode ()));
					list.add (new Triple (fk_node,
										  RDFS.domain.asNode (),
										  table_node));
					list.add (new Triple (fk_node,
										  RDFS.range.asNode (),
										  ftable_node));
					if (!fk.canBeNull ()) {
						AnonId aid = new AnonId ("restriction:"+fk_node.getURI());
						Node restriction = Node.createAnon (aid);
						list.add (new Triple (table_node,
											  RDFS.subClassOf.asNode(),
											  restriction));
						list.add (new Triple (restriction,
											  RDF.type.asNode(),
											  OWL.Restriction.asNode ()));
						list.add (new Triple (restriction,
											  OWL.onProperty.asNode(),
											  fk_node));
						list.add (new Triple (restriction,
											  OWL.someValuesFrom.asNode(),
											  ftable_node));
					}
					if (fk.unique) {
						list.add (new Triple (fk_node,
											  RDF.type.asNode (),
											  OWL.InverseFunctionalProperty.asNode ()));
					}
				} else {
					// rule 3b
					list.add (new Triple (table_node,
										  RDFS.subClassOf.asNode(),
										  ftable_node));
				}
			}

			// rule 4
			j = table.fkPairs.iterator();
			while (j.hasNext ()) {
				ForeignKey pair[] = (ForeignKey[]) j.next ();
				Table table0 = pair[0].foreignColumnSet (). table ();
				Node table0_node = Node.createURI (table0.uri);
				Table table1 = pair[1].foreignColumnSet (). table ();
				Node table1_node = Node.createURI (table1.uri);
				Node rel_node = Node.createURI (info.uri (pair[0], pair[1], table));
                    // TODO LATER maybe the URI of fk-pairs should be cached
                    //            just as table, column and fk URIs are
				list.add (new Triple (rel_node,
									  RDF.type.asNode (),
									  OWL.ObjectProperty.asNode ()));
				list.add (new Triple (rel_node,
									  RDFS.domain.asNode (),
									  table0_node));
				list.add (new Triple (rel_node,
									  RDFS.range.asNode (),
									  table1_node));
				if (pair[0].unique) {
					list.add (new Triple (rel_node,
										  RDF.type.asNode (),
										  OWL.FunctionalProperty.asNode ()));
				}
				if (pair[1].unique) {
					list.add (new Triple (rel_node,
										  RDF.type.asNode (),
										  OWL.InverseFunctionalProperty.asNode ()));
				}
			}
		}
		
		return list.iterator ();
	}

}
